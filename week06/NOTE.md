## 有限状态机模型

如何理解有限状态机?

想象为一台atm机器。每个机器里面，都需要有输入，进行计算，存储，输出。。
状态机本身没有状态，如果用函数表示的话，应该是纯函数。

每个机器都知道下一个的状态。
- 每个机器有着明确的下一个状态(Moore)
- 每个机器根据输入，决定下一个状态(Mealy)

在这里，采用的是 Mealy 的方式来设置状态机。

## HTML 的解析

主要分为几个步骤:

### 1. 拆分文件

- 使用parser，将html文本作为参数，返回的结果，是一个dom树。

### 2. 创建状态机

在 html的文档之中，提供了关于各个状态的设定。很神奇的一份文档，写好了所有的实现方式，翻译为代码即可。

[https://html.spec.whatwg.org/multipage/parsing.html#before-attribute-name-state]()

这里，使用FSM 来实现HTML的解析。

### 3. 解析标签

主要标签：
- 开始标签
- 结束标签
- 自封闭标签

### 4. 创建元素

- 状态机中，除了状态迁移，还要加入业务逻辑
- 状态结束，状态提交标签token

### 5. 处理属性

- 三种属性值的写法: 单引号，双引号，无引号三种写法。在html的文档之中，也设定了对应的处理方式。
- 处理属性的方式，跟处理标签相似
- 属性结束时，把属性加到token上。

### 6. 构建 DOM 树

- 使用stack，构建dom树
- 遇到开始标签时，入栈；遇到结束标签，出栈
- 自封闭节点，入栈后立即出栈
- 任何元素的父元素，是它入栈前的栈顶

### 7. 文本节点

- 文本节点与自封闭标签处理相似
- 多个文本节点需要合并

## CSS 计算规则和运用

### 1. 收集 CSS 规则

遇到style标签，保存css规则。
调用 CSS Parser 分析 CSS 规则，这里，使用了库，
需要研究这个库分析 CSS 规则的格式。

### 2. 添加调用

- 创建一个元素之后，立即计算 CSS
- 理论上，分析元素的时候，css 规则收集已经完成了。
- 实际上，可能遇到写在body之中的style标签，需要重新计算css。但是此处暂时忽略。

### 3. 获取父元素

在computeCSS时，必须知道元素的父元素，才能判断元素是否跟规则匹配。
根据Stack，获得本元素的所有父元素。
首先获得的是当前元素，所以，我们获得和计算父元素匹配的顺序是从内向外


### 4. 拆分选择器
- 从内向外排列
- 复杂选择器拆解为针对单个元素的选择器，用循环匹配父元素队列

### 5. 计算选择器和元素匹配

- 根据选择器类型和元素属性，计算是否匹配当前元素
- 实际浏览器需要处理复合选择器

### 6. 生成 computed 属性

- 一旦选择匹配，应用选择器到元素上，形成 computedStyle

###  7. 确定规则覆盖关系

- 根据specificity 和后来的优先规则覆盖
- specificity 是个四元组，越左边权重越高
- css规则的specificity根据包含的简单选择器相加而成


## 浏览器布局 layout 和 render


### 1. 收集元素


### 2. 确定主轴

计算主轴方向。
- 找出所有的flex元素
- 把主轴方向的剩余尺寸按照比例，分配给这些元素
- 若剩余空间为负数，所有flex元素为0.等比压缩剩余元素

### 3. 计算交叉轴

- 计算交叉轴方向
- 根据每一行中最大元素的尺寸，计算行高
- 根据行高 flex-align, item-align, 确定元素的具体位置











 